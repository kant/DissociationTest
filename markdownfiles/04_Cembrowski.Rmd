---
title: "04_Cembrowski.Rmd"
author: "Rayna M Harris"
date: December 20, 2017
#output: html_document
output:
  md_document:
  variant: markdown_github
---

## Cembrowski et all data reanalyzed

This ([2016 Cembrowski paper](https://elifesciences.org/content/5/e14997#fig1s30)) is very similar to my experiment, so I want to compare the two. Like mine, they compare hippocampal gene expression from dorsal CA1, CA3, and DG sub regions. These cells were identifed through fac sorting to isolate genetically labeled CA1 and CA3 pyramical neurons and DG granular cells.

Before beginning, I used the following UNIX commands to get their data.

This data was made available here [open source data](https://www.janelia.org/lab/spruston-lab/resources/source-data-simulation-code-other-resources), but I downloaded it from the GenBank archive using the following commands: 

~~~
mkdir ../data/Cembrowski
cd ../data/Cembrowski
wget 'ftp://ftp.ncbi.nlm.nih.gov/geo/series/GSE74nnn/GSE74985/suppl/GSE74985_gene_exp.diff.gz'
wget 'ftp://ftp.ncbi.nlm.nih.gov/geo/series/GSE74nnn/GSE74985/suppl/GSE74985_genes.fpkm_tracking.gz'
wget 'ftp://ftp.ncbi.nlm.nih.gov/geo/series/GSE74nnn/GSE74985/suppl/GSE74985_genes.read_group_tracking.txt.gz'
wget 'ftp://ftp.ncbi.nlm.nih.gov/geo/series/GSE74nnn/GSE74985/suppl/GSE74985_mergedCount.txt.gz'
gunzip *.gz
gzip GSE74985_genes.fpkm_tracking
cd ../../bin
~~~

The GSE74985_genes.fpkm_tracking file is used to extract the gene names with the corresponding ensembl gene id. The file must be unzipped for use in R, but it must be zipped in order to store it on GitHub. The 4985_mergedCount.txt file is used for gene expression analyis in R.


```{r setup, echo=FALSE, message=FALSE, results='hide',comment=FALSE, warning=FALSE}
#source("http://www.bioconductor.org/biocLite.R")
#biocLite("DESeq2")
library(DESeq2)
library(magrittr)
library(tidyverse)
library(plyr)
library(reshape2)
library(VennDiagram)
library(genefilter)
library(pheatmap)
library(edgeR)
library(colorRamps) # for a matlab like color scheme
library(viridis)
library(genefilter)  ## for PCA fuction
library(ggrepel) ## for labeling volcano plot


source("DESeqPCAfunction.R")
source("figureoptions.R")
source("resvalsfunction.R")

# set output file for figures 
knitr::opts_chunk$set(fig.path = '../figures/04_Cembrowski/')
```

```{r ImportData, echo=FALSE, message=FALSE, results='hide',comment=FALSE, warning=FALSE}
# contains a file with the gene name and transcript id
geneids <- read.table("../data/Cembrowski/geneids.tsv", header=T)

#read count data 
count <- read.table("../data/Cembrowski/GSE74985_mergedCount.txt")
count$gene_id <- row.names(count)

## join with geneids so we can look at gene level stuff
countbygene <- full_join(geneids, count)
countbygene <- countbygene %>% 
  filter(gene != "-")
countbygene <- countbygene[-c(1)] ## keep gene name and counts for samples)


## lengthen the dataframe, then wide with gene level sums, then make gene the row name, then round the value to nearest integer
countbygene <- melt(countbygene, id=c("gene")) 
countbygene  <- dcast(countbygene, gene ~ variable, value.var= "value", fun.aggregate=sum)
row.names(countbygene) <- countbygene$gene
countbygene[1] <- NULL
countbygene <- round(countbygene)

# getting ready for DESeq2
countData <- countbygene 


# extract the sample information
colData <- as.data.frame(colnames(countData))
names(colData)[1] <- "RNAseqID"
colData$region <- sapply(strsplit(as.character(colData$RNAseqID),'\\_'), "[", 1)
colData$location <- sapply(strsplit(as.character(colData$RNAseqID),'\\_'), "[", 2)


# rename variables and columns
colData <- rename(colData, c("region"="Region"))
colData <- rename(colData, c("location"="Location"))
colData$Region <- plyr::revalue(colData$Region, c("ca1"="CA1"))
colData$Region <- plyr::revalue(colData$Region, c("ca3"="CA3"))
colData$Region <- plyr::revalue(colData$Region, c("dg"="DG"))
colData$Location <- plyr::revalue(colData$Location, c("d"="dorsal"))
colData$Location <- plyr::revalue(colData$Location, c("v"="ventral"))

```

```{r SubsetData, echo=FALSE, message=FALSE, results='hide',comment=FALSE, warning=FALSE}
# keep only CA1, CA3, and DG data
colData <- colData %>% 
  filter(grepl("DG|CA1|CA3", Region))  %>% 
  droplevels() ## subsets data
savecols <- as.character(colData$RNAseqID) #select the sample name column that corresponds to row names
savecols <- as.vector(savecols) # make it a vector
countData <- countData %>% select(one_of(savecols))

# keep only data with >2 counts
countData[countData < 2] <- 0

# replace nas with 0
countData[is.na(countData)] <- 0
```

The first thing I notice is that they have waay more reads per sample and thus gene counts per sample than I do. They have a mean gene counts per sample around 400 million counts per gene. My data had 5 million counts per gene. 

```{r edgeR, echo=FALSE, message=FALSE, results='hide',comment=FALSE, warning=FALSE }
counts <- countData
dim( counts )
colSums( counts ) / 1e06  # in millions of reads
table( rowSums( counts ) )[ 1:30 ] # Number of genes with low counts

rowsum <- as.data.frame(colSums( counts ) / 1e06 )
names(rowsum)[1] <- "millioncounts"
rowsum$sample <- row.names(rowsum)

ggplot(rowsum, aes(x=millioncounts)) + 
  geom_histogram(bins = 20, colour = "black", fill = "darkgrey") +
  theme_classic() +
  scale_x_continuous(name = "Millions of Gene Counts per Sample",
                     breaks = seq(0, 900, 100),
                     limits=c(0, 900)) +
  scale_y_continuous(name = "Number of Samples")
```


This gene has the smalled pvalue of any in the DESeq model. It nicely shows the dyanmic range of a gene's expression from roughly 1,000 to 20,000 counts. 

```{r DifferentialGeneExpressionAnalysis, comment=FALSE, warning=FALSE}
dds <- DESeqDataSetFromMatrix(countData = countData,
                              colData = colData,
                              design = ~ Region + Location + Region * Location )
dds <- dds[ rowSums(counts(dds)) > 2, ] ## filter genes with 0 counts
dds <- DESeq(dds) # Differential expression analysis
dds

## for variance stablized gene expression and log transformed data
rld <- rlog(dds, blind=FALSE)
```


This PCA shows fantastic separation of all 6 sample types included in the anlaysis. DGs are separated from CAs by prcinciple compoent 1. CA1 and CA3 separate by princinple compent 2. Dorsal ventral groups are separated more along the diagonals.

```{r PCA, echo=FALSE, message=FALSE, results='hide',comment=FALSE, warning=FALSE}

# create the dataframe using my function pcadataframe
pcadata <- pcadataframe(rld, intgroup=c("Region", "Location"), returnData=TRUE)
percentVar <- round(100 * attr(pcadata, "percentVar"))

## PC1 vs PC2
plotPC1PC2(aescolor = pcadata$Region, colorname = "Region", aesshape = pcadata$Location, shapename = "Location", colorvalues = colorvalRegion)

myplot <- plotPC1PC2(aescolor = pcadata$Region, colorname = "Region", aesshape = pcadata$Location, shapename = "Location", colorvalues = colorvalRegion)
pdf(file="../figures/04_Cembrowski/PCA-1.pdf", width=4.5, height=3)
plot(myplot)
dev.off()

## PC2 vs PC3
plotPC2PC3(aescolor = pcadata$Region, colorname = "Region", aesshape = pcadata$Location, shapename = "Location", colorvalues = colorvalRegion)

myplot <- plotPC2PC3(aescolor = pcadata$Region, colorname = "Region", aesshape = pcadata$Location, shapename = "Location", colorvalues = colorvalRegion)
pdf(file="../figures/04_Cembrowski/PCA-2.pdf", width=4.5, height=3)
plot(myplot)
dev.off()

```


# For number look here!!!

```{r viewcoldata, echo=FALSE,message=FALSE, warning=FALSE}
colData %>% select(Location,Region)  %>%  summary()
```

```{r viewscountData, echo=FALSE,message=FALSE, warning=FALSE}
dim(countData)
```

```{r, echo=TRUE, message=TRUE,comment=FALSE, warning=FALSE}
dim(rld)
```


```{r, echo=TRUE, message=FALSE, comment=FALSE, warning=FALSE}
aov1 <- aov(PC1 ~ Region, data=pcadata)
summary(aov1) 
TukeyHSD(aov1, which = "Region") 
```


```{r, echo=TRUE, message=FALSE, comment=FALSE, warning=FALSE}
aov2 <- aov(PC2 ~ Region, data=pcadata)
summary(aov2) 
TukeyHSD(aov2, which = "Region") 

```

```{r, echo=TRUE, message=FALSE, comment=FALSE, warning=FALSE}
aov3 <- aov(PC3 ~ Location, data=pcadata)
summary(aov3) 
```

```{r, echo=TRUE, message=FALSE, comment=FALSE, warning=FALSE}
aov4 <- aov(PC4 ~ Location, data=pcadata)
summary(aov4) 
```




```{r VennDiagram, echo=FALSE, message=FALSE, results='hide',comment=FALSE, warning=FALSE}
contrast1 <- resvals(contrastvector = c('Region', 'CA1', 'DG'), mypval = 0.05)
contrast2 <- resvals(contrastvector = c('Region', 'CA3', 'DG'), mypval = 0.05)
contrast3 <- resvals(contrastvector = c('Region', 'CA1', 'CA3'), mypval = 0.05)
contrast4 <- resvals(contrastvector = c('Location', 'ventral', 'dorsal'), mypval = 0.05)

#create a new DF with the gene counts
rldpvals <- assay(rld)
rldpvals <- cbind(rldpvals, contrast1, contrast2, contrast3, contrast4)
rldpvals <- as.data.frame(rldpvals)
rldpvals <- rldpvals[ , grepl( "padj|pval" , names( rldpvals ) ) ]


# venn with padj values
venn1 <- row.names(rldpvals[rldpvals[1] <0.05 & !is.na(rldpvals[1]),])
venn2 <- row.names(rldpvals[rldpvals[3] <0.05 & !is.na(rldpvals[3]),])
venn3 <- row.names(rldpvals[rldpvals[5] <0.05 & !is.na(rldpvals[5]),])
venn4 <- row.names(rldpvals[rldpvals[7] <0.05 & !is.na(rldpvals[7]),])
venn12 <- union(venn1,venn2)
venn123 <- union(venn12,venn3)



candidates <- list("CA1 vs DG" = venn1, "CA1 vs CA3" = venn3,"CA3 vs DG" = venn2)

prettyvenn <- venn.diagram(scaled=T,
  x = candidates, filename=NULL, 
  col = "black",
  fill = c( "white", "white", "white"),
  alpha = 0.5,
  cex = 1, fontfamily = "sans", #fontface = "bold",
  cat.default.pos = "text",
  #cat.dist = c(0.1, 0.1, 0.1), cat.pos = 1,
  cat.cex = 1, 
  cat.fontfamily = "sans")
#dev.off()
grid.draw(prettyvenn)


# save results for meta anlayses
write(venn123, "../results/04_cembrowski_venn123.txt")
write(venn4, "../results/04_cembrowski_venn4.txt")
write(venn1, "../results/04_cembrowski_venn1.txt")

```

These are two heatmaps that I recreated with their data. Thousands of genes are differntially expression at p < 0.001 so I keep make the threshold more and more stringent until I got these plots. 

The top heatmap shows clean separation of each of the 6 groups. Dorsal CA1 are most different from the rest. Ventral CA1 and CA3 are similar to one another and to ventral CA3. DGs cluster well.

The bottom heat map is a much less stringent cutoff and this one cleanly separates first by brain region and then by dorsal ventral location.

```{r HeatmapPadj, echo=FALSE, message=FALSE, results='hide',comment=FALSE, warning=FALSE}
contrast1 <- resvals(contrastvector = c('Region', 'CA1', 'DG'), mypval = 0.05)
contrast2 <- resvals(contrastvector = c('Region', 'CA3', 'DG'), mypval = 0.05)
contrast3 <- resvals(contrastvector = c('Region', 'CA1', 'CA3'), mypval = 0.05)
contrast4 <- resvals(contrastvector = c('Location', 'ventral', 'dorsal'), mypval = 0.05)

## Any padj <0.05
DEGes <- assay(rld)
DEGes <- cbind(DEGes, contrast1, contrast2, contrast3, contrast4)
DEGes <- as.data.frame(DEGes) # convert matrix to dataframe
DEGes$rownames <- rownames(DEGes)  # add the rownames to the dataframe

DEGes$padjmin <- with(DEGes, pmin(pvalLocationventraldorsal, padjRegionCA1DG ,padjRegionCA3DG, padjRegionCA1CA3 )) # put the min pvalue in a new column
DEGes <- DEGes %>% filter(padjmin < 0.000000000001)

rownames(DEGes) <- DEGes$rownames
drop.cols <-colnames(DEGes[,grep("padj|pval|rownames", colnames(DEGes))])
DEGes <- DEGes %>% select(-one_of(drop.cols))
DEGes <- as.matrix(DEGes)
DEGes <- DEGes - rowMeans(DEGes)


# setting color options
ann_colors <- ann_colorscembrowksi
df <- as.data.frame(colData(dds)[,c( "Location", "Region")])

paletteLength <- 40
myBreaks <- c(seq(min(DEGes), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(DEGes)/paletteLength, max(DEGes), length.out=floor(paletteLength/2)))


pheatmap(DEGes, show_colnames=T, show_rownames = F,
         annotation_col=df, annotation_colors = ann_colors,
         treeheight_row = 0, treeheight_col = 50,
         fontsize = 11, 
         #width=4.5, height=3,
         border_color = "grey60" ,
         color = viridis(40),
         #cellwidth = 12, 
         clustering_distance_cols="correlation" ,
         breaks=myBreaks,
         clustering_method="average"
         )

# for adobe
pheatmap(DEGes, show_colnames=F, show_rownames = F,
         annotation_col=df, annotation_colors = ann_colors,
         treeheight_row = 25, treeheight_col = 25,
         fontsize = 11, 
         width=4.5, height=3,
         border_color = "grey60" ,
         color = viridis(40),
         cellwidth = 9, 
         clustering_distance_cols="correlation" ,
         breaks=myBreaks,
         clustering_method="average",
         filename = "../figures/04_Cembrowski/HeatmapPadj-1.pdf"
         )


library(superheat)
superheat(DEGes,
          # change the size of the labels
          #left.label.size = 0.25, 
          bottom.label.size = 0.2,
          bottom.label.text.angle = 90, 
          # cluster rows and add dendrogram
          pretty.order.cols = TRUE,
          pretty.order.rows = TRUE,
          # These two lines darken the color
          heat.lim = c(-2, 2), 
          extreme.values.na = FALSE,
          legend.breaks = c(-2, 0, 2))

```



```{r GOsetup, echo=FALSE, message=FALSE, comment=FALSE, warning=FALSE }
#create a new DF with the gene counts
GOpvals <- rldpvals
GOpvals$gene<-rownames(GOpvals)

GOpvals <- GOpvals %>%
  select(gene, pvalLocationventraldorsal)
GOpvals$logP <- log(GOpvals$pvalLocationventraldorsal)
GOpvals <- GOpvals %>%
  select(gene, logP)

write.csv(GOpvals, "./06_GO_MWU/04_cembrowski_GOpvals.csv", row.names = F)
```

```{r pvclust, echo=FALSE, message=FALSE, comment=FALSE, warning=FALSE, include=F }
library(pvclust)
# clustering just the degs
result <- pvclust(DEGes, method.dist="cor", method.hclust="average", nboot=1000)
plot(result)
```


```{r volcanos}
# gene lists
res <- results(dds, contrast =c("Region", "CA1", "DG"), independentFiltering = T, alpha = 0.05)
summary(res)
resOrdered <- res[order(res$padj),]
head(resOrdered, 10)
data <- data.frame(gene = row.names(res), pvalue = -log10(res$padj), lfc = res$log2FoldChange)
data <- na.omit(data)
data <- data %>%
  mutate(color = ifelse(data$lfc > 0 & data$pvalue > 1.3, 
                        yes = "CA1", 
                        no = ifelse(data$lfc < 0 & data$pvalue > 1.3, 
                                    yes = "DG", 
                                    no = "none")))
top_labelled <- top_n(data, n = 5, wt = pvalue)

# Color corresponds to fold change directionality
colored <- ggplot(data, aes(x = lfc, y = pvalue)) + 
  geom_point(aes(color = factor(color)), size = 1, alpha = 0.2, na.rm = T) + # add gene points
  theme_bw(base_size = 8) + # clean up theme
  theme(legend.position = "none") + # remove legend 
  scale_color_manual(values = c("CA1" = "#7570b3",
                                "DG" = "#d95f02", 
                                "none" = "#d9d9d9")) + theme(panel.grid.minor=element_blank(),
           panel.grid.major=element_blank()) + 
  scale_x_continuous(name="log2 (CA1/DG)",
                     limits=c(-30, 30)) +
  scale_y_continuous(name="-log10 (adjusted p-value)",
                    limits= c(0, 100)) +
  geom_hline(yintercept = 1.3,  size = 0.25, linetype = 2 )
colored
#cvd_grid(colored) # to view plot for color blind 
pdf(file="../figures/04_Cembrowski/AllCA1DG.pdf", width=1.5, height=1.75)
plot(colored)
dev.off()
```